# Kapitel 7 – Immutable vs mutable objekter

## 1. Introduktion

I dette kapitel undersøger vi forskellen mellem immutable og mutable objekter. Spørgsmålet er ikke blot teknisk – det er et designvalg.

Skal et objekt kunne ændre tilstand efter oprettelse? Eller bør det være uforanderligt?

Valget påvirker invariants, ansvar, testbarhed og kompleksitet.

## 2. Faglig gennemgang

Et immutable objekt ændrer ikke sin interne tilstand efter konstruktion. Name er et naturligt eksempel.

```
public class Name {

    private String firstName;
    private String lastName;

    public Name(String firstName, String lastName) {
        if (firstName == null || lastName == null) {
            throw new IllegalArgumentException();
        }
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFullName() {
        return firstName + " " + lastName;
    }
}
```
Der findes ingen setters. Objektet kan ikke ændres efter oprettelse.

Et mutable objekt kan derimod ændre tilstand. Clock er et typisk eksempel.

```
public class Clock {

    private int hour;
    private int minute;

    public Clock(int hour, int minute) {
        this.hour = hour;
        this.minute = minute;
    }

    public void tick() {
        minute++;
        if (minute == 60) {
            minute = 0;
            hour = (hour + 1) % 24;
        }
    }
}
```
Her ændrer metoden tick objektets interne tilstand.

## 3. Gennemgående eksempel – Name vs Clock

Et navn ændrer sig sjældent i domænet. Derfor giver immutability mening.

Et ur ændrer sig kontinuerligt. Derfor er mutability naturlig.

Designet bør afspejle domænets virkelighed – ikke blot sprogets muligheder.

## 4. Kodeeksempler

```
public Name changeLastName(String newLastName) {
    return new Name(firstName, newLastName);
}
```
I et immutable design skabes et nyt objekt frem for at ændre det eksisterende.

```
public void setHour(int hour) {
    if (hour < 0 || hour > 23) {
        throw new IllegalArgumentException();
    }
    this.hour = hour;
}
```
I et mutable design skal hver ændring stadig beskytte invarianten.

## 5. Designovervejelser

Fordele ved immutability:
- Enklere invariants
- Ingen skjulte sideeffekter
- Lettere test

Fordele ved mutability:
- Naturlig modellering af tilstande der ændrer sig
- Mindre objektoprettelse

Vælg immutability som udgangspunkt – og tillad mutability, når domænet kræver det.

## 6. Typiske fejl og misforståelser

1) At lave setters uden domænemæssig begrundelse.
2) At tro at immutable altid er bedst.
3) At glemme validering i mutable metoder.
4) At blande mutable og immutable uden klar strategi.

## 7. Refleksionsspørgsmål

1) Hvilke domænebegreber i et system bør være immutable?
2) Hvordan påvirker mutability testbarhed?
3) Hvornår kan immutability forenkle designet?

## 8. Små øvelser

Øvelse 1: Gør MyDate immutable.

Øvelse 2: Diskutér om en BankAccount bør være immutable eller mutable.
