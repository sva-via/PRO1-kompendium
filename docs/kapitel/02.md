# Kapitel 2 – Ansvar og indkapsling

## 1. Introduktion

I forrige kapitel så vi, at en klasse modellerer et begreb. Men at modellere et begreb er ikke blot at samle data og metoder.

Det centrale spørgsmål er: Hvad er denne klasses ansvar?

Ansvar og indkapsling er fundamentale i objektorienteret design. Uden klar ansvarsfordeling ender man med klasser, der ved for meget, gør for meget eller overlader for meget til andre.

Dette kapitel handler om klassens ansvar, hvad der ikke bør være dens ansvar, getter/setter som designvalg samt representation exposure.

## 2. Hvad er klassens ansvar?

En klasse repræsenterer et begreb. Ansvar betyder: Hvad skal objektet kunne garantere om sig selv?

For Name kan ansvaret være at repræsentere et gyldigt navn og kunne give sit fulde navn.

```
public class Name {

    private String firstName;
    private String lastName;

    public Name(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFullName() {
        return firstName + " " + lastName;
    }
}
```
Klassen ved noget om navne – ikke om databaser, udskrivning eller infrastruktur.

## 3. Hvad bør ikke være dens ansvar?

En klasse bør ikke påtage sig uafhængige tekniske ansvar som konsoludskrift eller databaseadgang.

```
public void printToConsole() {
    System.out.println(getFullName());
}
```
Udskrivning er præsentation og hører ikke til i domænemodellen.

Høj cohesion betyder, at klassen har ét klart formål. Lav cohesion gør systemet svært at vedligeholde.

## 4. Indkapsling

Indkapsling betyder, at objektets interne tilstand beskyttes. Felter bør derfor være private.

```
private String firstName;
private String lastName;
```
Hvis felterne var public, kunne enhver ændre dem direkte, og objektet ville miste kontrol.

## 5. Getter og setter som designvalg

Getters og setters er ikke automatiske krav. De er designvalg.

Hvis et objekt ikke bør ændres efter oprettelse, skal der ikke være setters.

```
public String getFirstName() {
    return firstName;
}
```
En setter giver kun mening, hvis ændringen er en naturlig del af begrebet, og klassen fortsat kan garantere sin invariant.

## 6. Representation exposure

Representation exposure opstår, når et objekt afslører sin interne repræsentation.

```
public class Person {

    private Name name;

    public Name getName() {
        return name;
    }
}
```
Hvis Name er mutable, kan eksterne ændringer påvirke Person direkte.

```
person.getName().setFirstName("Edsger");
```
Dette bryder indkapslingen. En løsning kan være at returnere en kopi.

```
public Name getName() {
    return new Name(name.getFirstName(), name.getLastName());
}
```
## 7. Designovervejelser

Klar ansvarsfordeling giver høj cohesion, lav coupling og bedre testbarhed.

Dårlig ansvarsfordeling fører til gud-klasser og spredt logik.

## 8. Typiske fejl og misforståelser

1) Private felter + getters/setters er ikke automatisk god OOP.
2) Intern repræsentation eksponeres uden overvejelse.
3) Domæneklasser gives teknisk ansvar.
4) Klasser får for mange ansvar.

## 9. Refleksionsspørgsmål

1) Hvad betyder det konkret, at en klasse har ansvar?
2) Hvornår er en setter et tegn på svagt design?
3) Hvordan kan representation exposure bryde en invariant?

## 10. Små øvelser

Øvelse 1:
Redesign følgende klasse:

```
public class Account {
    public double balance;
}
```
Hvilket ansvar mangler, og hvordan bør det beskyttes?

Øvelse 2:
Diskutér hvornår det er sikkert at returnere et internt objekt direkte.
