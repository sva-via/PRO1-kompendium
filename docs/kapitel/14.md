# Kapitel 14 – MyDate – en robust dato

## 1. Introduktion

I dette kapitel samler vi centrale begreber fra tidligere kapitler i én samlet implementering: en robust version af klassen MyDate.

Målet er ikke blot at få dato-logik til at virke, men at demonstrere:
- Klare invariants
- Korrekt håndtering af leap year
- Kontrolleret tilstandsændring via stepForwardOneDay
- Præcis sammenligning via isBefore

## 2. Invariant for MyDate

Invarianten for MyDate kan formuleres således:
- year >= 1
- 1 <= month <= 12
- day er gyldig i den givne måned og det givne år

```
public class MyDate {

    private int year;
    private int month;
    private int day;

    public MyDate(int year, int month, int day) {
        if (!isValidDate(year, month, day)) {
            throw new IllegalArgumentException("Invalid date");
        }
        this.year = year;
        this.month = month;
        this.day = day;
    }
}
```
## 3. Leap year

Reglen for leap year er:

- År deleligt med 4 er skudår
- Undtagen år deleligt med 100
- Medmindre det også er deleligt med 400

```
private boolean isLeapYear(int year) {
    if (year % 400 == 0) return true;
    if (year % 100 == 0) return false;
    return year % 4 == 0;
}
```
Denne metode bruges i valideringen af februar.

```
private int daysInMonth(int year, int month) {

    switch (month) {
        case 1: case 3: case 5: case 7:
        case 8: case 10: case 12:
            return 31;
        case 4: case 6: case 9: case 11:
            return 30;
        case 2:
            return isLeapYear(year) ? 29 : 28;
        default:
            throw new IllegalArgumentException("Invalid month");
    }
}
private boolean isValidDate(int year, int month, int day) {
    if (year < 1) return false;
    if (month < 1 || month > 12) return false;
    if (day < 1) return false;
    return day <= daysInMonth(year, month);
}
```
## 4. stepForwardOneDay

```
public void stepForwardOneDay() {

    day++;

    if (day > daysInMonth(year, month)) {
        day = 1;
        month++;

        if (month > 12) {
            month = 1;
            year++;
        }
    }
}
```
Metoden bevarer invarianten ved at normalisere datoen, hvis dagen overskrider månedens grænse.

## 5. isBefore

```
public boolean isBefore(MyDate other) {

    if (this.year != other.year) {
        return this.year < other.year;
    }

    if (this.month != other.month) {
        return this.month < other.month;
    }

    return this.day < other.day;
}
```
Metoden sammenligner år, derefter måned og til sidst dag. Sammenligningen følger domænets naturlige orden.

## 6. Designovervejelser

Valget mellem mutable og immutable design bør overvejes.

En mutable MyDate kræver omhyggelig kontrol i alle metoder, mens en immutable version kan gøre designet enklere.

Valget afhænger af domænets behov.

## 7. Typiske fejl og misforståelser

1) At glemme leap year i februar.
2) At validere måned og dag uafhængigt.
3) At bryde invarianten midlertidigt.
4) At ignorere boundary values som 31.12.

## 8. Refleksionsspørgsmål

1) Hvorfor bør leap year-logik kapsles i en separat metode?
2) Hvordan sikrer stepForwardOneDay, at invarianten bevares?
3) Kunne MyDate med fordel være immutable?

## 9. Små øvelser

Øvelse 1: Implementér en metode daysUntil(MyDate other).

Øvelse 2: Gør MyDate immutable og tilpas stepForwardOneDay.
