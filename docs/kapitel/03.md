# Kapitel 3 – Invariants

## 1. Introduktion

I de foregående kapitler har vi arbejdet med ansvar og indkapsling. Nu formaliserer vi noget, der allerede har ligget implicit: Hvad må aldrig være sandt for et objekt?

Dette kaldes en invariant.

En invariant er en regel om objektets tilstand, som altid skal være opfyldt efter konstruktion og efter enhver offentlig metode.

I dette kapitel arbejder vi med invariants, beskyttelse af objektets tilstand og eksemplet MyDate og ulovlige datoer.

## 2. Hvad er en invariant?

For klassen Name kunne en invariant være, at felterne firstName og lastName aldrig må være null.

For klassen MyDate kunne invarianten være, at år er positivt, måned er mellem 1 og 12, og dag er gyldig i den givne måned.

## 3. En naiv MyDate

```
public class MyDate {

    private int year;
    private int month;
    private int day;

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }
}
```
Her kan vi oprette ulovlige datoer som måned 13 eller dag 45. Invarianten håndhæves ikke.

## 4. Objektet skal beskytte sig selv

```
public MyDate(int year, int month, int day) {

    if (year < 1) {
        throw new IllegalArgumentException("Year must be positive");
    }

    if (month < 1 || month > 12) {
        throw new IllegalArgumentException("Invalid month");
    }

    if (day < 1 || day > 31) {
        throw new IllegalArgumentException("Invalid day");
    }

    this.year = year;
    this.month = month;
    this.day = day;
}
```
Her bruges IllegalArgumentException til at afvise input, der bryder invarianten.

## 5. Samlet validering

```
private boolean isValidDate(int year, int month, int day) {

    if (month < 1 || month > 12) return false;
    if (day < 1) return false;

    int maxDays = 31;

    if (month == 4 || month == 6 || month == 9 || month == 11) {
        maxDays = 30;
    }

    if (month == 2) {
        maxDays = 28;
    }

    return day <= maxDays;
}
public MyDate(int year, int month, int day) {

    if (!isValidDate(year, month, day)) {
        throw new IllegalArgumentException("Invalid date");
    }

    this.year = year;
    this.month = month;
    this.day = day;
}
```
## 6. Invariant efter konstruktion

```
public void setMonth(int month) {
    this.month = month;
}
```
En simpel setter kan bryde invarianten, hvis den ikke validerer samlet tilstand.

## 7. Immutable design

```
public MyDate nextDay() {
    return new MyDate(year, month, day + 1);
}
```
Ved at undgå setters og skabe nye objekter kan invarianten kontrolleres ét sted.

## 8. Designovervejelser

Strict design afviser ugyldigt input med exceptions. Tolerant design forsøger at rette input. I domænemodeller er strict design normalt at foretrække.

## 9. Typiske fejl

1. At tro at invariant blot er dokumentation.
2. At validere kun i brugergrænsefladen.
3. At bruge setters uden samlet kontrol.
4. At acceptere midlertidig ugyldig tilstand.

## 10. Refleksionsspørgsmål

1. Hvorfor må et objekt aldrig eksistere i ugyldig tilstand?
2. Hvorfor skal validering ligge i objektet selv?
3. Hvordan hænger indkapsling og invariants sammen?

## 11. Små øvelser

Øvelse 1: Udvid MyDate med skudår.

```
private boolean isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}
```
Øvelse 2: Design en klasse Temperature med invariant om absolut nulpunkt.
